/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import {
  containsBytes,
  fixEncoderSize,
  getBytesEncoder,
  type Address,
  type ReadonlyUint8Array,
} from 'gill';
import {
  type ParsedCloseStreamInstruction,
  type ParsedCreateStreamInstruction,
  type ParsedEmployerEmergencyWithdrawInstruction,
  type ParsedRefreshActivityInstruction,
  type ParsedTopUpStreamInstruction,
  type ParsedWithdrawInstruction,
} from '../instructions';

export const CASCADE_PROGRAM_ADDRESS =
  '6erxegH47t73aQjWm3fZEkwva57tz2JH7ZMxdoayzxVQ' as Address<'6erxegH47t73aQjWm3fZEkwva57tz2JH7ZMxdoayzxVQ'>;

export enum CascadeAccount {
  PaymentStream,
}

export function identifyCascadeAccount(
  account: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CascadeAccount {
  const data = 'data' in account ? account.data : account;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([124, 85, 193, 22, 93, 1, 143, 75])
      ),
      0
    )
  ) {
    return CascadeAccount.PaymentStream;
  }
  throw new Error(
    'The provided account could not be identified as a cascade account.'
  );
}

export enum CascadeInstruction {
  CloseStream,
  CreateStream,
  EmployerEmergencyWithdraw,
  RefreshActivity,
  TopUpStream,
  Withdraw,
}

export function identifyCascadeInstruction(
  instruction: { data: ReadonlyUint8Array } | ReadonlyUint8Array
): CascadeInstruction {
  const data = 'data' in instruction ? instruction.data : instruction;
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([255, 241, 196, 212, 95, 93, 160, 89])
      ),
      0
    )
  ) {
    return CascadeInstruction.CloseStream;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([71, 188, 111, 127, 108, 40, 229, 158])
      ),
      0
    )
  ) {
    return CascadeInstruction.CreateStream;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([53, 243, 175, 174, 220, 22, 246, 211])
      ),
      0
    )
  ) {
    return CascadeInstruction.EmployerEmergencyWithdraw;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([55, 172, 115, 3, 200, 89, 189, 250])
      ),
      0
    )
  ) {
    return CascadeInstruction.RefreshActivity;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([12, 244, 26, 215, 160, 204, 9, 151])
      ),
      0
    )
  ) {
    return CascadeInstruction.TopUpStream;
  }
  if (
    containsBytes(
      data,
      fixEncoderSize(getBytesEncoder(), 8).encode(
        new Uint8Array([183, 18, 70, 156, 148, 109, 161, 34])
      ),
      0
    )
  ) {
    return CascadeInstruction.Withdraw;
  }
  throw new Error(
    'The provided instruction could not be identified as a cascade instruction.'
  );
}

export type ParsedCascadeInstruction<
  TProgram extends string = 'J2A6twQYqg61SqDeKPzoNo5MXoFhVaDnQ6MC4vjB2yZi',
> =
  | ({
      instructionType: CascadeInstruction.CloseStream;
    } & ParsedCloseStreamInstruction<TProgram>)
  | ({
      instructionType: CascadeInstruction.CreateStream;
    } & ParsedCreateStreamInstruction<TProgram>)
  | ({
      instructionType: CascadeInstruction.EmployerEmergencyWithdraw;
    } & ParsedEmployerEmergencyWithdrawInstruction<TProgram>)
  | ({
      instructionType: CascadeInstruction.RefreshActivity;
    } & ParsedRefreshActivityInstruction<TProgram>)
  | ({
      instructionType: CascadeInstruction.TopUpStream;
    } & ParsedTopUpStreamInstruction<TProgram>)
  | ({
      instructionType: CascadeInstruction.Withdraw;
    } & ParsedWithdrawInstruction<TProgram>);
