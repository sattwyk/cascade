/**
 * This code was AUTOGENERATED using the Codama library.
 * Please DO NOT EDIT THIS FILE, instead use visitors
 * to add features, then rerun Codama to update it.
 *
 * @see https://github.com/codama-idl/codama
 */

import { combineCodec, fixDecoderSize, fixEncoderSize, getAddressEncoder, getBytesDecoder, getBytesEncoder, getProgramDerivedAddress, getStructDecoder, getStructEncoder, getU64Decoder, getU64Encoder, transformEncoder, type AccountMeta, type AccountSignerMeta, type Address, type FixedSizeCodec, type FixedSizeDecoder, type FixedSizeEncoder, type Instruction, type InstructionWithAccounts, type InstructionWithData, type ReadonlyAccount, type ReadonlyUint8Array, type TransactionSigner, type WritableAccount, type WritableSignerAccount } from 'gill';
import { CASCADE_PROGRAM_ADDRESS } from '../programs';
import { expectAddress, getAccountMetaFactory, type ResolvedAccount } from '../shared';

export const CREATE_STREAM_DISCRIMINATOR = new Uint8Array([71, 188, 111, 127, 108, 40, 229, 158]);

export function getCreateStreamDiscriminatorBytes() { return fixEncoderSize(getBytesEncoder(), 8).encode(CREATE_STREAM_DISCRIMINATOR); }

export type CreateStreamInstruction<TProgram extends string = typeof CASCADE_PROGRAM_ADDRESS, TAccountEmployer extends string | AccountMeta<string> = string, TAccountEmployee extends string | AccountMeta<string> = string, TAccountMint extends string | AccountMeta<string> = string, TAccountStream extends string | AccountMeta<string> = string, TAccountVault extends string | AccountMeta<string> = string, TAccountEmployerTokenAccount extends string | AccountMeta<string> = string, TAccountTokenProgram extends string | AccountMeta<string> = "TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA", TAccountSystemProgram extends string | AccountMeta<string> = "11111111111111111111111111111111", TAccountRent extends string | AccountMeta<string> = "SysvarRent111111111111111111111111111111111", TRemainingAccounts extends readonly AccountMeta<string>[] = []> =
Instruction<TProgram> & InstructionWithData<ReadonlyUint8Array> & InstructionWithAccounts<[TAccountEmployer extends string ? WritableSignerAccount<TAccountEmployer> & AccountSignerMeta<TAccountEmployer> : TAccountEmployer, TAccountEmployee extends string ? ReadonlyAccount<TAccountEmployee> : TAccountEmployee, TAccountMint extends string ? ReadonlyAccount<TAccountMint> : TAccountMint, TAccountStream extends string ? WritableAccount<TAccountStream> : TAccountStream, TAccountVault extends string ? WritableAccount<TAccountVault> : TAccountVault, TAccountEmployerTokenAccount extends string ? WritableAccount<TAccountEmployerTokenAccount> : TAccountEmployerTokenAccount, TAccountTokenProgram extends string ? ReadonlyAccount<TAccountTokenProgram> : TAccountTokenProgram, TAccountSystemProgram extends string ? ReadonlyAccount<TAccountSystemProgram> : TAccountSystemProgram, TAccountRent extends string ? ReadonlyAccount<TAccountRent> : TAccountRent, ...TRemainingAccounts]>;

export type CreateStreamInstructionData = { discriminator: ReadonlyUint8Array; hourlyRate: bigint; totalDeposit: bigint;  };

export type CreateStreamInstructionDataArgs = { hourlyRate: number | bigint; totalDeposit: number | bigint;  };

export function getCreateStreamInstructionDataEncoder(): FixedSizeEncoder<CreateStreamInstructionDataArgs> {
    return transformEncoder(getStructEncoder([['discriminator', fixEncoderSize(getBytesEncoder(), 8)], ['hourlyRate', getU64Encoder()], ['totalDeposit', getU64Encoder()]]), (value) => ({ ...value, discriminator: CREATE_STREAM_DISCRIMINATOR }));
}

export function getCreateStreamInstructionDataDecoder(): FixedSizeDecoder<CreateStreamInstructionData> {
    return getStructDecoder([['discriminator', fixDecoderSize(getBytesDecoder(), 8)], ['hourlyRate', getU64Decoder()], ['totalDeposit', getU64Decoder()]]);
}

export function getCreateStreamInstructionDataCodec(): FixedSizeCodec<CreateStreamInstructionDataArgs, CreateStreamInstructionData> {
    return combineCodec(getCreateStreamInstructionDataEncoder(), getCreateStreamInstructionDataDecoder());
}

export type CreateStreamAsyncInput<TAccountEmployer extends string = string, TAccountEmployee extends string = string, TAccountMint extends string = string, TAccountStream extends string = string, TAccountVault extends string = string, TAccountEmployerTokenAccount extends string = string, TAccountTokenProgram extends string = string, TAccountSystemProgram extends string = string, TAccountRent extends string = string> =  {
  employer: TransactionSigner<TAccountEmployer>;
employee: Address<TAccountEmployee>;
mint: Address<TAccountMint>;
stream?: Address<TAccountStream>;
vault?: Address<TAccountVault>;
employerTokenAccount: Address<TAccountEmployerTokenAccount>;
tokenProgram?: Address<TAccountTokenProgram>;
systemProgram?: Address<TAccountSystemProgram>;
rent?: Address<TAccountRent>;
hourlyRate: CreateStreamInstructionDataArgs["hourlyRate"];
totalDeposit: CreateStreamInstructionDataArgs["totalDeposit"];
}

export async function getCreateStreamInstructionAsync<TAccountEmployer extends string, TAccountEmployee extends string, TAccountMint extends string, TAccountStream extends string, TAccountVault extends string, TAccountEmployerTokenAccount extends string, TAccountTokenProgram extends string, TAccountSystemProgram extends string, TAccountRent extends string, TProgramAddress extends Address = typeof CASCADE_PROGRAM_ADDRESS>(input: CreateStreamAsyncInput<TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent>, config?: { programAddress?: TProgramAddress } ): Promise<CreateStreamInstruction<TProgramAddress, TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent>> {
  // Program address.
const programAddress = config?.programAddress ?? CASCADE_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { employer: { value: input.employer ?? null, isWritable: true }, employee: { value: input.employee ?? null, isWritable: false }, mint: { value: input.mint ?? null, isWritable: false }, stream: { value: input.stream ?? null, isWritable: true }, vault: { value: input.vault ?? null, isWritable: true }, employerTokenAccount: { value: input.employerTokenAccount ?? null, isWritable: true }, tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }, systemProgram: { value: input.systemProgram ?? null, isWritable: false }, rent: { value: input.rent ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;


// Original args.
const args = { ...input,  };


// Resolve default values.
if (!accounts.stream.value) {
accounts.stream.value = await getProgramDerivedAddress({ programAddress, seeds: [getBytesEncoder().encode(new Uint8Array([115, 116, 114, 101, 97, 109])), getAddressEncoder().encode(expectAddress(accounts.employer.value)), getAddressEncoder().encode(expectAddress(accounts.employee.value))] });
}
if (!accounts.vault.value) {
accounts.vault.value = await getProgramDerivedAddress({ programAddress, seeds: [getBytesEncoder().encode(new Uint8Array([118, 97, 117, 108, 116])), getAddressEncoder().encode(expectAddress(accounts.stream.value))] });
}
if (!accounts.tokenProgram.value) {
accounts.tokenProgram.value = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
}
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}
if (!accounts.rent.value) {
accounts.rent.value = 'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
}

const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta(accounts.employer), getAccountMeta(accounts.employee), getAccountMeta(accounts.mint), getAccountMeta(accounts.stream), getAccountMeta(accounts.vault), getAccountMeta(accounts.employerTokenAccount), getAccountMeta(accounts.tokenProgram), getAccountMeta(accounts.systemProgram), getAccountMeta(accounts.rent)], data: getCreateStreamInstructionDataEncoder().encode(args as CreateStreamInstructionDataArgs), programAddress } as CreateStreamInstruction<TProgramAddress, TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent>);
}

export type CreateStreamInput<TAccountEmployer extends string = string, TAccountEmployee extends string = string, TAccountMint extends string = string, TAccountStream extends string = string, TAccountVault extends string = string, TAccountEmployerTokenAccount extends string = string, TAccountTokenProgram extends string = string, TAccountSystemProgram extends string = string, TAccountRent extends string = string> =  {
  employer: TransactionSigner<TAccountEmployer>;
employee: Address<TAccountEmployee>;
mint: Address<TAccountMint>;
stream: Address<TAccountStream>;
vault: Address<TAccountVault>;
employerTokenAccount: Address<TAccountEmployerTokenAccount>;
tokenProgram?: Address<TAccountTokenProgram>;
systemProgram?: Address<TAccountSystemProgram>;
rent?: Address<TAccountRent>;
hourlyRate: CreateStreamInstructionDataArgs["hourlyRate"];
totalDeposit: CreateStreamInstructionDataArgs["totalDeposit"];
}

export function getCreateStreamInstruction<TAccountEmployer extends string, TAccountEmployee extends string, TAccountMint extends string, TAccountStream extends string, TAccountVault extends string, TAccountEmployerTokenAccount extends string, TAccountTokenProgram extends string, TAccountSystemProgram extends string, TAccountRent extends string, TProgramAddress extends Address = typeof CASCADE_PROGRAM_ADDRESS>(input: CreateStreamInput<TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent>, config?: { programAddress?: TProgramAddress } ): CreateStreamInstruction<TProgramAddress, TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent> {
  // Program address.
const programAddress = config?.programAddress ?? CASCADE_PROGRAM_ADDRESS;

 // Original accounts.
const originalAccounts = { employer: { value: input.employer ?? null, isWritable: true }, employee: { value: input.employee ?? null, isWritable: false }, mint: { value: input.mint ?? null, isWritable: false }, stream: { value: input.stream ?? null, isWritable: true }, vault: { value: input.vault ?? null, isWritable: true }, employerTokenAccount: { value: input.employerTokenAccount ?? null, isWritable: true }, tokenProgram: { value: input.tokenProgram ?? null, isWritable: false }, systemProgram: { value: input.systemProgram ?? null, isWritable: false }, rent: { value: input.rent ?? null, isWritable: false } }
const accounts = originalAccounts as Record<keyof typeof originalAccounts, ResolvedAccount>;


// Original args.
const args = { ...input,  };


// Resolve default values.
if (!accounts.tokenProgram.value) {
accounts.tokenProgram.value = 'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA' as Address<'TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA'>;
}
if (!accounts.systemProgram.value) {
accounts.systemProgram.value = '11111111111111111111111111111111' as Address<'11111111111111111111111111111111'>;
}
if (!accounts.rent.value) {
accounts.rent.value = 'SysvarRent111111111111111111111111111111111' as Address<'SysvarRent111111111111111111111111111111111'>;
}

const getAccountMeta = getAccountMetaFactory(programAddress, 'programId');
return Object.freeze({ accounts: [getAccountMeta(accounts.employer), getAccountMeta(accounts.employee), getAccountMeta(accounts.mint), getAccountMeta(accounts.stream), getAccountMeta(accounts.vault), getAccountMeta(accounts.employerTokenAccount), getAccountMeta(accounts.tokenProgram), getAccountMeta(accounts.systemProgram), getAccountMeta(accounts.rent)], data: getCreateStreamInstructionDataEncoder().encode(args as CreateStreamInstructionDataArgs), programAddress } as CreateStreamInstruction<TProgramAddress, TAccountEmployer, TAccountEmployee, TAccountMint, TAccountStream, TAccountVault, TAccountEmployerTokenAccount, TAccountTokenProgram, TAccountSystemProgram, TAccountRent>);
}

export type ParsedCreateStreamInstruction<TProgram extends string = typeof CASCADE_PROGRAM_ADDRESS, TAccountMetas extends readonly AccountMeta[] = readonly AccountMeta[]> = { programAddress: Address<TProgram>;
accounts: {
employer: TAccountMetas[0];
employee: TAccountMetas[1];
mint: TAccountMetas[2];
stream: TAccountMetas[3];
vault: TAccountMetas[4];
employerTokenAccount: TAccountMetas[5];
tokenProgram: TAccountMetas[6];
systemProgram: TAccountMetas[7];
rent: TAccountMetas[8];
};
data: CreateStreamInstructionData; };

export function parseCreateStreamInstruction<TProgram extends string, TAccountMetas extends readonly AccountMeta[]>(instruction: Instruction<TProgram> & InstructionWithAccounts<TAccountMetas> & InstructionWithData<ReadonlyUint8Array>): ParsedCreateStreamInstruction<TProgram, TAccountMetas> {
  if (instruction.accounts.length < 9) {
  // TODO: Coded error.
  throw new Error('Not enough accounts');
}
let accountIndex = 0;
const getNextAccount = () => {
  const accountMeta = (instruction.accounts as TAccountMetas)[accountIndex]!;
  accountIndex += 1;
  return accountMeta;
}
  return { programAddress: instruction.programAddress, accounts: { employer: getNextAccount(), employee: getNextAccount(), mint: getNextAccount(), stream: getNextAccount(), vault: getNextAccount(), employerTokenAccount: getNextAccount(), tokenProgram: getNextAccount(), systemProgram: getNextAccount(), rent: getNextAccount() }, data: getCreateStreamInstructionDataDecoder().decode(instruction.data) };
}